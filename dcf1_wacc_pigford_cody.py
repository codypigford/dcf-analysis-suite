# -*- coding: utf-8 -*-
"""DCF1 WACC - Pigford-Cody.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sIrtI-SxU8DqU3m-yXiPdT_I9UGQ7vYA

# DCF Part 1: WACC

In this notebook, we will compute the weighted average cost of capital.

$WACC = w_E * k_E + w_D * k_D * (1-t)$

Steps to get there:
1. Get firm data to compute Equity and Debt weights ($w_E$ and $w_D$)
2. Compute the cost of equity using the CAPM: $k_E = r_f + B_i * EMRP$

We'll get the risk free rate from market data.
We'll use an OLS regression to compute our own Beta.
The EMRP we will take as given.

3. Compute the cost of debt: $k_D = r_f + spread$

The $spread$ is the default spread given a firm's credit rating. We'll use a lookup table using current data to get the spread.

4. $t$ is the marginal tax rate, which we'll take as 25%.
5. Put it all together!

This is our in-class project that we will work on progressively through the mod.

Expectations:
1. Notebook is clean and neat, with no repeated code. It has clearly labeled sections for inputs/imports at the beginning. Code is sufficiently commented to demonstrate your understanding of the code and help you or anyone else who may use this code later. All numbers should be formatted so they are readable (so, use commas with large numbers, only a few decimal points).
2. All calculations are correct and all discussion questions are answered completely but concisely, demonstrating a depth of understanding.

Workflow:
1. Notebooks are inherently experimental and allow you to try things, however that requires some good habits
2. Once you are "done" in any sense, you always need to "clean up" your notebook to make it presentable. You'd do the same in Excel - you've tried lots of things, etc. but before you present it, you clean it up.
3. Finally, restart the Runtime/Kernel and run it cleanly all the way top to bottom one time.

Then, its ready to go.

# 1 Always put Imports and Installs at the beginning

And only put them in once.

Set display options here if you are using them.

Set API Keys here if you need them.
"""

# necessary imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf

import yfinance as yf

# Format setting for the model - tame the decimals!
pd.reset_option('display.float_format')
pd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))

# install the FRED API for economic data
# This is necessary since Google Colab does not have this package installed already
!pip install fredapi

# import
import fredapi
# These two lines set the API Key so you can access FRED data with your credentials
from google.colab import userdata
fred = fredapi.Fred(api_key=userdata.get('FRED_APIKey'))

"""# 2 Gather inputs, assumptions, parameters at the beginning

This is a place for anything that you may want to change in the future. The rest of the notebook should just be code that runs, generating the necessary output, plots, etc.

### Assumptions and paramters

"""

# Set Ticker we are modeling
ticker_symbol = 'MSFT'
company_name = "Microsoft"
firm_rating = "Aaa/AAA"

# choose the "market" for our beta - get from Yahoo! Finance
index_symbol = '^GSPC'
index_name = 'S&P 500'

# get risk free rate from FRED
# first, get the whole series
rf_series = fred.get_series('DGS10')

# get the most recent value, divide by 100 to make it a decimal like all others
rf = rf_series.iloc[-1] / 100

emrp = 0.05 # given
marg_tax_rate = 0.25 # for WACC, given

# this is what we divide numbers by, 1000000 is $M
scale_factor = 1000000
scale_name = '$M'

print(f"Risk Free Rate: {rf:.2%}")

"""# 3 Begin Calculations and Modeling

**From here, nothing should be hardcoded**

## Debt and Equity Weights
"""

# Create a Ticker object
ticker = yf.Ticker(ticker_symbol)
info = ticker.info
# Get the market cap
market_cap = info.get('marketCap') / scale_factor

# Get the total debt
total_debt = info.get('totalDebt') / scale_factor

print(f"Market Capitalization for {ticker_symbol}: {market_cap:,.2f}")
print(f"Total Debt for {ticker_symbol}: {total_debt:,.2f}")

# compute equity and debt weights
w_E = market_cap / (market_cap + total_debt)
w_D = total_debt / (market_cap + total_debt)

print(f"Equity Weight for {ticker_symbol}: {w_E:,.2f}")
print(f"Debt Weight for {ticker_symbol}: {w_D:,.2f}")

"""## Cost of Equity

Really this is just beta because the other two are either given or looked up already.
"""

# Download historical data for the firm and S&P 500
# get five years of monthly data
stock_data = yf.download(ticker_symbol, period='5y', interval='1mo')['Close']
index_data = yf.download(index_symbol, period='5y', interval='1mo')['Close']

# Calculate monthly returns for stock and S&P 500, minus risk free rate
stock_returns = stock_data.pct_change().dropna() - rf
index_returns = index_data.pct_change().dropna() - rf

# Run OLS regression, be sure to add a constant to index returns
# this will use the statsmodels package (don't forget to import above...)

X = sm.add_constant(index_returns)
model = sm.OLS(stock_returns, X)
results = model.fit()

# Print out the regression results
print(results.summary())

# Get the beta - it is the coefficient on the index return, not the constant
beta = results.params[index_symbol]

print(f"Beta for {ticker_symbol}: {beta:.2f}")

# Calculate the cost of equity using CAPM
cost_of_equity = rf + beta * emrp

print(f"Cost of Equity for {ticker_symbol}: {cost_of_equity:.2%}")

"""## Cost of Debt

Really, just the spread is all we need.

I have a table that I like to use from Aswath Damodaran.
[Here is the link.](https://people.stern.nyu.edu/adamodar/New_Home_Page/datafile/ratings.html)


I updated it with the following prompt in ChatGPT:

*I have the following list structure for credit spreads in python:*

```
# updated as of January 2024:
credit_spreads = [
    {"GreaterThan": -100000, "LessThan": 0.199999, "Rating": "D2/D", "Spread": 20.00},
    {"GreaterThan": 0.2, "LessThan": 0.649999, "Rating": "C2/C", "Spread": 17.00},
    {"GreaterThan": 0.65, "LessThan": 0.799999, "Rating": "Ca2/CC", "Spread": 11.78},
    {"GreaterThan": 0.8, "LessThan": 1.249999, "Rating": "Caa/CCC", "Spread": 8.51},
    {"GreaterThan": 1.25, "LessThan": 1.499999, "Rating": "B3/B-", "Spread": 5.24},
    {"GreaterThan": 1.5, "LessThan": 1.749999, "Rating": "B2/B", "Spread": 3.61},
    {"GreaterThan": 1.75, "LessThan": 1.999999, "Rating": "B1/B+", "Spread": 3.14},
    {"GreaterThan": 2, "LessThan": 2.2499999, "Rating": "Ba2/BB", "Spread": 2.21},
    {"GreaterThan": 2.25, "LessThan": 2.49999, "Rating": "Ba1/BB+", "Spread": 1.74},
    {"GreaterThan": 2.5, "LessThan": 2.999999, "Rating": "Baa2/BBB", "Spread": 1.47},
    {"GreaterThan": 3, "LessThan": 4.249999, "Rating": "A3/A-", "Spread": 1.21},
    {"GreaterThan": 4.25, "LessThan": 5.499999, "Rating": "A2/A", "Spread": 1.07},
    {"GreaterThan": 5.5, "LessThan": 6.499999, "Rating": "A1/A+", "Spread": 0.92},
    {"GreaterThan": 6.5, "LessThan": 8.499999, "Rating": "Aa2/AA", "Spread": 0.70},
    {"GreaterThan": 8.5, "LessThan": 100000, "Rating": "Aaa/AAA", "Spread": 0.59}
]
```
*Please update it with this new data (copied from a web site):*
```
If interest coverage ratio is
>	â‰¤ to	Rating is	Spread is
-100000	0.199999	D2/D	19.00%
0.2	0.649999	C2/C	15.50%
0.65	0.799999	Ca2/CC	10.10%
0.8	1.249999	Caa/CCC	7.28%
1.25	1.499999	B3/B-	4.42%
1.5	1.749999	B2/B	3.00%
1.75	1.999999	B1/B+	2.61%
2	2.2499999	Ba2/BB	1.83%
2.25	2.49999	Ba1/BB+	1.55%
2.5	2.999999	Baa2/BBB	1.20%
3	4.249999	A3/A-	0.95%
4.25	5.499999	A2/A	0.85%
5.5	6.499999	A1/A+	0.77%
6.5	8.499999	Aa2/AA	0.60%
8.50	100000	Aaa/AAA	0.45%
And that seems to work
"""

# Updated credit spreads for large non-financial service firms (as of latest data)
credit_spreads = [
    {"GreaterThan": -100000, "LessThan": 0.199999, "Rating": "D2/D", "Spread": 19.00},
    {"GreaterThan": 0.2, "LessThan": 0.649999, "Rating": "C2/C", "Spread": 15.50},
    {"GreaterThan": 0.65, "LessThan": 0.799999, "Rating": "Ca2/CC", "Spread": 10.10},
    {"GreaterThan": 0.8, "LessThan": 1.249999, "Rating": "Caa/CCC", "Spread": 7.28},
    {"GreaterThan": 1.25, "LessThan": 1.499999, "Rating": "B3/B-", "Spread": 4.42},
    {"GreaterThan": 1.5, "LessThan": 1.749999, "Rating": "B2/B", "Spread": 3.00},
    {"GreaterThan": 1.75, "LessThan": 1.999999, "Rating": "B1/B+", "Spread": 2.61},
    {"GreaterThan": 2.0, "LessThan": 2.2499999, "Rating": "Ba2/BB", "Spread": 1.83},
    {"GreaterThan": 2.25, "LessThan": 2.49999, "Rating": "Ba1/BB+", "Spread": 1.55},
    {"GreaterThan": 2.5, "LessThan": 2.999999, "Rating": "Baa2/BBB", "Spread": 1.20},
    {"GreaterThan": 3.0, "LessThan": 4.249999, "Rating": "A3/A-", "Spread": 0.95},
    {"GreaterThan": 4.25, "LessThan": 5.499999, "Rating": "A2/A", "Spread": 0.85},
    {"GreaterThan": 5.5, "LessThan": 6.499999, "Rating": "A1/A+", "Spread": 0.77},
    {"GreaterThan": 6.5, "LessThan": 8.499999, "Rating": "Aa2/AA", "Spread": 0.60},
    {"GreaterThan": 8.5, "LessThan": 100000, "Rating": "Aaa/AAA", "Spread": 0.45}
]

"""Here we are going to write a function. Remember, we'll do this in two overall steps:

1. Write a script (not a function) that does what you want it to do and check and be sure that all the logic works.
2. Turn that script into a function with inputs and outputs, etc.
"""

# write a function. It should take two inputs:
# 1. rating, a string variable that represents the firm's credit rating
# 2. credit_spreads, a list of dictionaries that has a lookup table from Damodaran's website.
# The table is in the above cell.
#
# The output should return a credit spread, which is a float data type.
# If no match is found, it should print a warning and return a NaN

def get_credit_spread(rating, credit_spreads):
    """
    Looks up the credit spread for a given credit rating.

    Args:
        rating (str): The credit rating of the firm.
        credit_spreads (list): A list of dictionaries containing credit spread data.

    Returns:
        float: The credit spread in percentage points, or NaN if no match is found.
    """
    for entry in credit_spreads:
        if entry["Rating"].strip().lower() == rating.strip().lower():
            return float(entry["Spread"])/100
    print(f"Warning: No spread found for rating {rating}")
    return np.nan


# Example usage

credit_spread = get_credit_spread(firm_rating, credit_spreads)

print(f"The spread for {ticker_symbol}'s rating ({firm_rating}) is: {credit_spread:.2%}")

# compute cost of debt: risk free rate plus credit spread
cost_of_debt = rf + credit_spread

print(f"Cost of Debt for {ticker_symbol}: {cost_of_debt:.2%}")

"""## Finally, compute the WACC

put it all together
"""

# Calculate WACC
wacc = w_E * cost_of_equity + w_D * cost_of_debt * (1 - marg_tax_rate)

print(f"WACC for {ticker_symbol}: {wacc:.2%}")

"""# Homework: What about Uncertainty?

Our estimate of beta has a range of uncertainty about it - a 95% confidence interval.

**HOMEWORK**

1. Go back to the OLS above and find the lower and upper CI for beta. Do this programmatically (i.e., find it in the `results` object)
2. Recompute a *lower* and *upper* WACC based on that *lower* and *upper* beta

If you are completely stuck, you should hard code the upper and Lower CI so you can turn this in, but there will be a deduction.

Expected output: A DataFrame, one column, three rows, with the Lower CI, the Estimate, and Upper CI version of the WACC, in that order.
"""

# Get the confidence interval for beta from the OLS results
beta_ci = results.conf_int(alpha=0.05)
print(beta_ci)
print()

# Extract the lower and upper bounds of the beta confidence interval
beta_lower_ci = beta_ci.loc[index_symbol, 0]
beta_upper_ci = beta_ci.loc[index_symbol, 1]

# Calculate the lower and upper bounds of the cost of equity using the CI of beta
cost_of_equity_lower_ci = rf + beta_lower_ci * emrp
cost_of_equity_upper_ci = rf + beta_upper_ci * emrp

# Calculate the lower and upper WACC based on the CI of cost of equity
wacc_lower_ci = w_E * cost_of_equity_lower_ci + w_D * cost_of_debt * (1 - marg_tax_rate)
wacc_upper_ci = w_E * cost_of_equity_upper_ci + w_D * cost_of_debt * (1 - marg_tax_rate)

# Create a DataFrame to display the results
wacc_summary = pd.DataFrame({
    'WACC': [wacc_lower_ci, wacc, wacc_upper_ci]
}, index=['Lower CI', 'Estimate', 'Upper CI'])

# Display the DataFrame
print(wacc_summary*100)

