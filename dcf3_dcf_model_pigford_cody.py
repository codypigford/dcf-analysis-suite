# -*- coding: utf-8 -*-
"""DCF3 DCF Model - Pigford-Cody.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f9PlIbIAdFh2ITGT19srTtDua9X48CUg

# DCF Part 3: Final Model

Here we bring it all together. The end goal here is to get a DCF model-implied share price.

Plan:

1. Start with LTM data to get the most recent starting point
2. Use assumptions about projections. These will be hardcoded up front, including projected revenue growth, margins, and reinvestment rate. All must be for the same number of years in the future.
3. Create projections dataframe such that Year 1 is 12 months from the LTM data we just retrieved.
4. Use projected ratios to generate $-value projections from Revenue to NOPAT to FCF.
5. Discount FCF to the present
6. Compute Terminal Value using Gordon Growth Model, Discount to PV
7. Compute model-implied firm value and compute share price

This is our in-class project that we will work on progressively through the mod.

Expectations:
1. Notebook is clean and neat, with no repeated code. It has clearly labeled sections for inputs/imports at the beginning. Code is sufficiently commented to demonstrate your understanding of the code and help you or anyone else who may use this code later. All numbers should be formatted so they are readable (so, use commas with large numbers, only a few decimal points).
2. All calculations are correct and all discussion questions are answered completely but concisely, demonstrating a depth of understanding.

Workflow:
1. Notebooks are inherently experimental and allow you to try things, however that requires some good habits
2. Once you are "done" in any sense, you always need to "clean up" your notebook to make it presentable. You'd do the same in Excel - you've tried lots of things, etc. but before you present it, you clean it up.
3. Finally, restart the Runtime/Kernel and run it cleanly all the way top to bottom one time.

Then, its ready to go.

# Always put Imports and Installs at the beginning

And only put them in once.

Set display options here if you are using them.

Set API Keys here if you need them.
"""

# necessary imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

import yfinance as yf

# Set Ticker we are modeling
ticker_symbol = 'MSFT'

# need to set Effective Tax Rate, validate
eff_tax_rate = 0.19
marg_tax_rate = 0.25

# Set scale factor
scale_factor = 1000000
scale_name = 'M'

# Format setting for the model - tame the decimals!

pd.reset_option('display.float_format')
pd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))

"""## 1 Assumptions about Projection Patterns

This is a "minmimalist" model which means we only need the following:
1. Revenue Growth: To project Revenue
2. EBIT Margin: Go from Revenue to EBIT
3. Effective Tax Rate: Go from EBIT to NOPAT
4. Reinvestment Rate: Go from NOPAT to FCF


"""

ss_growth = 0.03
growth_pattern = [.20, .15, .15, .15, .10, 0.10, 0.10, 0.08, 0.08, 0.06] #must be list the same length as time_horizon

reinv_rate_pattern = [0.4, 0.4, 0.3, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
assert len(growth_pattern) == len(reinv_rate_pattern), "Time patterns do not match - Reinv Rate."

ebit_margin = [0.46, 0.46, 0.46, 0.46, 0.46, 0.46, 0.46, 0.46, 0.46, 0.46]
assert len(growth_pattern) == len(ebit_margin), "Time patterns do not match - EBIT."

time_horizon = len(growth_pattern)
print(f"Length of projection period: {len(growth_pattern)} years")

# Create a Ticker object
ticker = yf.Ticker(ticker_symbol)

# Get shares outstanding data
shares_outstanding = ticker.info['sharesOutstanding']

print(f"Shares Outstanding for {ticker_symbol}: {shares_outstanding/scale_factor:,.2f} {scale_name}")

"""## 2 Need LTM Data for starting point

Yahoo! Finance does not have LTM data - you need to create it yourself. Really all we need is LTM Revenue.
"""

# get LTM data from yfinance
ltm_data = ticker.quarterly_income_stmt.T.sort_index()

#keep the last 4 quarters of data using the .iloc() method
ltm_data = ltm_data.iloc[-4:]

# print it out
ltm_data.info()

# If you don't have it already, create this variable `ltm_revenue` that is a float (not dataframe), with only revenue, scaled.
ltm_revenue = ltm_data['Total Revenue'].sum()

print(f"Most Recent LTM Revenue for {ticker_symbol} is (${scale_name}): {ltm_revenue/scale_factor:,.2f}")

# here is the most recent date from which we begin our projections - this should be a datetime data type (not a string or float or int, etc.)
most_recent_date = ltm_data.index[-1]

print(f"Most Recent Date for {ticker_symbol}'s Quarterly Data: {most_recent_date}")

"""## 3 Create dataframe for projections

This is just gathering our assumptions and using the right dates for them
"""

# GIVEN: Just run this code. This is a bit more advanced than I expect most of you can do
#        Feel free to paste it into ChatGPT for a more in-depth explanation.
# this cell gets the dates for our projections going forward

# first, a lookup dictionary that allows us to convert a numeric month to a specific code for datetime objects
# the "A" stands for annual, so these codes will generate Annual intervals starting in that month, which is our goal.
freq_dict = {1:'YE-JAN',2:'YE-FEB',3:'YE-MAR',4:'YE-APR', 5:'YE-MAY',6:'YE-JUN',
             7:'YE-JUL',8:'YE-AUG', 9:'YE-SEP',10:'YE-OCT',11:'YE-NOV',12:'YE-DEC'}

# most_recent_date.month is an integer 1-12 representing the month part of the date.
# So, can you tell what this does?
f = freq_dict[most_recent_date.month]
#print result
print(f"This should match month above for most recent month in the above code cell: {f}\n")

# Generate the new dates for the DataFrame, matching the "growth_pattern" list above
new_dates = pd.date_range(start=most_recent_date, periods=len(growth_pattern)+1, freq=f)

print(f"Dates going forward, starting with time 0:")
print(new_dates)
print("\n")

# Create the projections DataFrame using the new_dates as index
# and the provided lists of projections given above as columns
# BE CAREFUL of dates. The above cell generates a sequence of dates starting today (T=0)
#                      The list objects with projections by definition start at T=1.


projection = pd.DataFrame(index=new_dates[1:], data={
    'Revenue Growth': growth_pattern, 'EBIT Margin': ebit_margin,
    'Reinv Rate': reinv_rate_pattern})

# print
projection

"""## 4 Now create projections in $"""

# Given LTM revenue and the revenue growth pattern (the python list above)
# generate the $M projections for revenue
# (this may take a few lines of code, not just one or two)
# Ensure reinv_rate_pattern is a NumPy array
reinv_rate_pattern = np.array(reinv_rate_pattern)

# 1. Calculate cumulative revenue
projection['Revenue'] = ltm_revenue * (1 + projection['Revenue Growth']).cumprod()

# 2. EBIT = Revenue × EBIT Margin
projection['EBIT'] = projection['Revenue'] * projection['EBIT Margin']

# 3. NOPAT = EBIT × (1 - tax rate)
projection['NOPAT'] = projection['EBIT'] * (1 - eff_tax_rate)

# 4. FCF = NOPAT × (1 - Reinvestment Rate)
projection['FCF'] = projection['NOPAT'] * (1- reinv_rate_pattern)

# Add the projections as columns to the projection_multipliers DataFrame


# print them out
ratios=['Revenue Growth', 'EBIT Margin', 'Reinv Rate']
values=['Revenue', 'EBIT', 'NOPAT', 'FCF']
display(projection[ratios])
display(projection[values]/scale_factor)

"""## 5 Get WACC from our WACC notebook

We did this already, so just need to import it.

I put the following prompt in ChatGPT:
```
take this data:

	WACC
0	7.67
1	8.72
2	9.77

and make it so I can turn it into a pandas dataframe if I paste the code
```
"""

# using our WACC notebook and some AI help, create a data frame for WACC.
# It should look like the dataframe shown above in the text block.
# It may take several lines of code.

data = {
    'WACC': [7.96, 9.25, 10.54]
}

# Create the DataFrame
wacc_df = pd.DataFrame(data)
print(wacc_df)
# Also, for a first pass, we need a single wacc, so set this float value:
wacc = wacc_df['WACC'][1]/100

print(f"WACC: {wacc:,.4f}")

"""## 6 Discount FCF to Present"""

# Calculate the present value of future cash flows
periods = np.arange(1, len(projection) + 1)

# Calculate discounted FCFs
projection['Discounted FCF'] = projection['FCF'] / (1 + wacc) ** periods

# print
projection[['FCF','Discounted FCF']]

"""## 7 PV of Terminal Value"""

# Calculate the terminal value using the Gordon Growth Model (also known as the Perpetuity Growth Model)
terminal_value = projection['FCF'].iloc[-1] * (1 + ss_growth) / (wacc - ss_growth)

# Print the terminal value

print(f"TV for {ticker_symbol}: {terminal_value:,.2f}")

# discount it to the present
present_value_of_terminal = terminal_value / (1 + wacc) ** len(projection)

print(f"PV of TV for {ticker_symbol}: {present_value_of_terminal:,.2f}")

"""## 8 Firm Value and Share Price"""

# compute PV of firm value
firm_value = projection['Discounted FCF'].sum() + present_value_of_terminal

print(f"Firm Value for {ticker_symbol}: {firm_value:,.2f}")


# compute share price

total_debt = ticker.info['totalDebt']
total_cash = ticker.info['totalCash']
share_price = (firm_value - total_debt + total_cash) / shares_outstanding

print(f"Share Price for {ticker_symbol}: ${share_price:,.2f}")

"""## 9 Visualizing Uncertainty

Let's take our upper and lower WACC to quantify the uncertainty in our share price estimate.

What you are doing here is creating a loop from what we just did:
1. Create a for loop that iterates through the three estimates of WACC
2. For each wacc, compute the PV of intermediate FCF, TV, PV of TV and share price
3. The output should be a list of share prices, upper, middle (what we just computed) and lower.

Its good to repeate the middle wacc calculation to validate it is the same as above.
"""

share_prices = []

for current_wacc_percent in wacc_df['WACC']:
    current_wacc = current_wacc_percent / 100

    # Calculate discounted FCFs for the current WACC
    current_projection = projection.copy()
    current_projection['Discounted FCF'] = current_projection['FCF'] / (1 + current_wacc) ** periods

    # Calculate terminal value for the current WACC
    current_terminal_value = current_projection['FCF'].iloc[-1] * (1 + ss_growth) / (current_wacc - ss_growth)

    # Discount terminal value to the present for the current WACC
    current_present_value_of_terminal = current_terminal_value / (1 + current_wacc) ** len(current_projection)

    # Compute firm value for the current WACC
    current_firm_value = current_projection['Discounted FCF'].sum() + current_present_value_of_terminal

    # Compute share price for the current WACC
    current_share_price = (current_firm_value - total_debt + total_cash) / shares_outstanding
    share_prices.append(current_share_price)

# Assign the share prices to variables for clarity
lower_share_price = share_prices[0]
middle_share_price = share_prices[1]
upper_share_price = share_prices[2]

print(f"Share Price (Lower WACC): ${lower_share_price:,.2f}")
print(f"Share Price (Middle WACC): ${middle_share_price:,.2f}")
print(f"Share Price (Upper WACC): ${upper_share_price:,.2f}")

"""Now create a plot!

1. Get 1 year historical stock prices data for the `ticker`
2. Plot it
3. Also plot, as horizontal lines, the upper, middle, and lower stock price estimates
4. Shade the area between the upper and lower stock price

Be sure to use accurate and informative axis labels, plot titles, etc. with correct units.

"""

# Download daily stock prices for the last year
historical_data = yf.download(ticker_symbol, period="1y")

# Create the plot
plt.figure(figsize=(12, 6))

# Plot the daily stock prices
plt.plot(historical_data.index, historical_data['Close'], label=f'{ticker_symbol} Historical Price', color='blue')

# Plot the horizontal lines for the main estimate and the confidence intervals
plt.axhline(middle_share_price, color='green', linestyle='--', label=f'Middle Estimate (${middle_share_price:,.2f})')
plt.axhline(lower_share_price, color='red', linestyle='--', label=f'Upper Estimate (${lower_share_price:,.2f})')
plt.axhline(upper_share_price, color='purple', linestyle='--', label=f'Lower Estimate (${upper_share_price:,.2f})')

# Shade the area between the upper and lower stock price
plt.fill_between(historical_data.index, lower_share_price, upper_share_price, color='gray', alpha=0.2, label='Estimate Range')

# Add title and labels
plt.title(f'{ticker_symbol} Share Price Estimates vs. Historical Data')
plt.xlabel('Date')
plt.ylabel('Share Price ($)')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

